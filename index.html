<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>準備中だよ！！</title>
    <!-- p5.jsライブラリを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <!-- Google Fontsから丸ゴシック体を読み込み -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@800&display=swap" rel="stylesheet">
    <style>
        /* CSS変数でテーマカラーを定義 */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --button-bg-color: rgba(0, 0, 0, 0.05);
            --button-border-color: rgba(0, 0, 0, 0.2);
            --button-hover-bg-color: rgba(0, 0, 0, 0.1);
            --text-shadow-color: rgba(255, 255, 255, 0.7);
        }

        [data-theme="dark"] {
            --bg-color: #000000;
            --text-color: #ffffff;
            --button-bg-color: rgba(255, 255, 255, 0.1);
            --button-border-color: rgba(255, 255, 255, 0.5);
            --button-hover-bg-color: rgba(255, 255, 255, 0.2);
            --text-shadow-color: rgba(0, 0, 0, 0.7);
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: var(--bg-color);
            transition: background-color 0.5s ease;
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
            flex-direction: column;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #text-overlay {
            position: relative;
            z-index: 2;
            color: var(--text-color);
            font-family: 'M PLUS Rounded 1c', 'Arial Rounded MT Bold', sans-serif;
            font-size: 120px;
            font-weight: 800;
            text-align: center;
            text-shadow: 0px 0px 25px var(--text-shadow-color);
            padding: 0 20px;
            transition: color 0.5s ease, text-shadow 0.5s ease;
        }

        #button-container {
            position: absolute;
            bottom: 50px;
            z-index: 3;
        }

        #generate-button {
            background-color: var(--button-bg-color);
            border: 2px solid var(--button-border-color);
            color: var(--text-color);
            padding: 15px 30px;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-size: 18px;
            font-weight: 500;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--button-hover-bg-color);
        }

        #generate-button:hover {
            background-color: var(--button-hover-bg-color);
            box-shadow: 0 0 25px var(--button-hover-bg-color);
        }

        #generate-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            #text-overlay { font-size: 80px; }
            #generate-button { font-size: 16px; padding: 12px 24px; }
        }
        @media (max-width: 480px) {
            #text-overlay { font-size: 48px; }
            #generate-button { font-size: 14px; padding: 10px 20px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="text-overlay">準備中</div>
        <div id="button-container">
            <button id="generate-button">次は何色かな？</button>
        </div>
    </div>
    <script>
        // --- グローバル変数 ---
        let particles = [];
        const numParticles = 50;
        let voronoiShader;

        // 初期カラーパレット
        let colorPalette = [
            '#E0FBFC', '#C2DFE3', '#AEECEF', '#86BBD8',
            '#97C1A9', '#C6E2E9', '#F4F1DE', '#E8DAB2',
            '#BDE4A8', '#A2D5AB', '#87C38F', '#6B9D7F'
        ];

        // --- シェーダーコード ---
        // 頂点シェーダー (Vertex Shader): 画面全体を覆うための基本的なシェーダー
        const vertShader = `
            attribute vec3 aPosition;
            attribute vec2 aTexCoord;
            varying vec2 vTexCoord;
            void main() {
                vTexCoord = aTexCoord;
                vec4 positionVec4 = vec4(aPosition, 1.0);
                positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
                gl_Position = positionVec4;
            }
        `;

        // フラグメントシェーダー (Fragment Shader): 各ピクセルの色を計算する
        const fragShader = `
            precision mediump float;
            uniform vec2 u_resolution;
            uniform int u_num_points;
            uniform vec2 u_points[${numParticles}];
            uniform vec3 u_colors[${numParticles}];

            void main() {
                vec2 st = gl_FragCoord.xy;
                
                float min_dist = 1.0e10; // 最も近い点への距離
                vec3 final_color = vec3(0.0); // 最も近い点の色

                // 最も近い点とその色を見つける
                for (int i = 0; i < ${numParticles}; i++) {
                    if (i >= u_num_points) break;
                    
                    float d = distance(st, u_points[i]);
                    if (d < min_dist) {
                        min_dist = d;
                        final_color = u_colors[i];
                    }
                }
                
                gl_FragColor = vec4(final_color, 1.0);
            }
        `;

        // --- p5.js スケッチ ---
        function setup() {
            // レンダラーをWEBGLに変更
            let canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.parent('canvas-container');
            
            // シェーダーをコンパイル
            voronoiShader = createShader(vertShader, fragShader);

            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle());
            }
            
            noStroke(); // WEBGLモードではstrokeを無効化
        }

        function draw() {
            // 1. パーティクルの物理演算を更新
            for (let particle of particles) {
                particle.update();
            }
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    particles[i].checkCollision(particles[j]);
                }
                particles[i].edges();
            }

            // 2. シェーダーを適用
            shader(voronoiShader);

            // 3. シェーダーにデータを送る
            let positions = [];
            let colors = [];
            for (const p of particles) {
                positions.push(p.pos.x, p.pos.y);
                let c = color(p.color);
                colors.push(red(c) / 255.0, green(c) / 255.0, blue(c) / 255.0);
            }
            
            voronoiShader.setUniform('u_resolution', [width, height]);
            voronoiShader.setUniform('u_num_points', particles.length);
            voronoiShader.setUniform('u_points', positions);
            voronoiShader.setUniform('u_colors', colors);

            // 4. 画面全体を覆う四角形を描画してシェーダーを実行
            rect(-width / 2, -height / 2, width, height);
            
            // 5. 描画結果全体にガウスぼかしを適用
            // この値が大きいほど、ぼかしが強くなります
            filter(BLUR, 15);
        }

        // --- Particle クラス ---
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.pos = createVector(random(width), random(height));
                this.vel = p5.Vector.random2D().mult(random(0.5, 2.5));
                this.size = random(40, 80);
                this.mass = this.size * 0.5;
                this.color = random(colorPalette);
            }

            update() {
                this.pos.add(this.vel);
            }

            checkCollision(other) {
                let distanceVect = p5.Vector.sub(other.pos, this.pos);
                let distance = distanceVect.mag();
                let minDistance = this.size / 2 + other.size / 2;

                if (distance < minDistance) {
                    let distanceCorrection = (minDistance - distance) / 2.0;
                    let d = distanceVect.copy();
                    let correctionVector = d.normalize().mult(distanceCorrection);
                    other.pos.add(correctionVector);
                    this.pos.sub(correctionVector);

                    let v1 = this.vel;
                    let v2 = other.vel;
                    let m1 = this.mass;
                    let m2 = other.mass;

                    let newVelX1 = (v1.x * (m1 - m2) + (2 * m2 * v2.x)) / (m1 + m2);
                    let newVelY1 = (v1.y * (m1 - m2) + (2 * m2 * v2.y)) / (m1 + m2);
                    let newVelX2 = (v2.x * (m2 - m1) + (2 * m1 * v1.x)) / (m1 + m2);
                    let newVelY2 = (v2.y * (m2 - m1) + (2 * m1 * v1.y)) / (m1 + m2);

                    this.vel.x = newVelX1;
                    this.vel.y = newVelY1;
                    other.vel.x = newVelX2;
                    other.vel.y = newVelY2;
                }
            }

            edges() {
                if (this.pos.x < 0 || this.pos.x > width) {
                    this.vel.x *= -1;
                }
                if (this.pos.y < 0 || this.pos.y > height) {
                    this.vel.y *= -1;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            for (let particle of particles) {
                // ウィンドウリサイズ時にパーティクルの位置を再設定
                particle.pos.x = random(width);
                particle.pos.y = random(height);
            }
        }

        // --- テーマ切り替え & Gemini API ---
        document.addEventListener('DOMContentLoaded', () => {
            const generateButton = document.getElementById('generate-button');
            const colorSchemeQuery = window.matchMedia('(prefers-color-scheme: dark)');

            const applyTheme = (isDark) => {
                document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
            };

            applyTheme(colorSchemeQuery.matches);
            colorSchemeQuery.addEventListener('change', e => applyTheme(e.matches));

            generateButton.addEventListener('click', async () => {
                const originalButtonText = "次は何色かな？";
                generateButton.textContent = '生成中...';
                generateButton.disabled = true;

                try {
                    const prompt = "美しい流体アニメーションに合う、調和のとれたパステルカラーの配色を12色、16進数カラーコードのJSON配列形式で生成してください。例: [\"#RRGGBB\", \"#RRGGBB\"]";
                    const newPaletteText = await callGemini(prompt);
                    const newPalette = JSON.parse(newPaletteText);
                    
                    if (Array.isArray(newPalette) && newPalette.length > 0) {
                        colorPalette = newPalette;
                        // 色が変更されたら、各パーティクルの色も更新
                        for(let p of particles) {
                            p.color = random(colorPalette);
                        }
                    } else {
                        throw new Error("Invalid palette format");
                    }

                } catch (error) {
                    console.error('Error generating palette:', error);
                } finally {
                    generateButton.disabled = false;
                    generateButton.textContent = originalButtonText;
                }
            });
        });

        // Gemini APIを呼び出す関数
        async function callGemini(prompt, retries = 3, delay = 1000) {
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        description: "12色の16進数カラーコードのリスト。",
                        items: {
                            type: "STRING",
                            pattern: "^#[0-9a-fA-F]{6}$"
                        }
                    }
                }
            };

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                    const result = await response.json();
                    
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        return result.candidates[0].content.parts[0].text.trim();
                    } else {
                        throw new Error('Invalid response structure from API');
                    }
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error);
                    if (i === retries - 1) throw error;
                    await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
                }
            }
        }
    </script>
</body>
</html>
