<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- ズーム防止機能を追加したviewport設定 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
    <title>逗逗の夢</title>
    <!-- Google FontsのCSSをインライン化 -->
    <style>
      /* cyrillic-ext */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2A8o5I.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }
      /* cyrillic */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2E8o5I.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }
      /* greek-ext */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2Awo5I.woff2) format('woff2');
        unicode-range: U+1F00-1FFF;
      }
      /* greek */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2M8o5I.woff2) format('woff2');
        unicode-range: U+0370-03FF;
      }
      /* hebrew */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2I8o5I.woff2) format('woff2');
        unicode-range: U+0590-05FF, U+200C-2010, U+20AA, U+25CC, U+FB1D-FB4F;
      }
      /* vietnamese */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2A0o5I.woff2) format('woff2');
        unicode-range: U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;
      }
      /* latin-ext */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2A4o5I.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }
      /* latin */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2c8.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
      /* japanese */
      @font-face {
        font-family: 'M PLUS Rounded 1c';
        font-style: normal;
        font-weight: 800;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/mplusrounded1c/v19/VdG-g6aVso-JpYI2gUe2A6w5-UTl-2Iu_2Y8o5I.woff2) format('woff2');
        unicode-range: U+3000-303F, U+3040-309F, U+30A0-30FF, U+FF00-FFEF;
      }
    </style>
    <style>
        /* CSS変数でテーマカラーを定義 */
        :root {
            --bg-color: #ffffff;
            --button-bg-color: rgba(0, 0, 0, 0.05);
            --button-border-color: rgba(0, 0, 0, 0.2);
            --button-hover-bg-color: rgba(0, 0, 0, 0.1);
            /* テキストのグラデーションとグロウの色をCSS変数で管理 */
            --gradient-color-1: #4169E1;
            --gradient-color-2: #8A2BE2;
        }

        [data-theme="dark"] {
            --bg-color: #000000;
            --button-bg-color: rgba(255, 255, 255, 0.1);
            --button-border-color: rgba(255, 255, 255, 0.5);
            --button-hover-bg-color: rgba(255, 255, 255, 0.2);
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: var(--bg-color);
            transition: background-color 0.5s ease;
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
            flex-direction: column;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #text-overlay {
            position: relative;
            z-index: 2;
            font-family: 'M PLUS Rounded 1c', 'Arial Rounded MT Bold', sans-serif;
            font-size: 120px;
            font-weight: 800;
            text-align: center;
            padding: 0 20px;
            
            background: linear-gradient(0deg, var(--gradient-color-2), var(--gradient-color-1), var(--gradient-color-2));
            background-size: 100% 200%;
            color: transparent;
            -webkit-background-clip: text;
            background-clip: text;
            
            filter: 
                drop-shadow(0 0 5px rgba(255, 255, 255, 0.9)) 
                drop-shadow(0 0 15px rgba(255, 255, 255, 0.6))
                drop-shadow(0 0 30px rgba(255, 255, 255, 0.3));
            
            animation: gradient-scroll 5s ease-in-out infinite;
        }

        @keyframes gradient-scroll {
            0% { background-position: 0% 0%; }
            50% { background-position: 0% 100%; }
            100% { background-position: 0% 0%; }
        }

        #button-container {
            position: absolute;
            bottom: 50px;
            z-index: 3;
        }

        #generate-button {
            background-color: var(--button-bg-color);
            border: 2px solid var(--button-border-color);
            color: var(--bg-color); 
            -webkit-text-fill-color: initial;
            padding: 15px 30px;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-size: 18px;
            font-weight: 500;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px var(--button-hover-bg-color);
        }

        #generate-button:hover {
            background-color: var(--button-hover-bg-color);
            box-shadow: 0 0 25px var(--button-hover-bg-color);
        }

        @media (max-width: 1024px) {
            #text-overlay { font-size: 100px; }
            #generate-button { font-size: 16px; padding: 12px 24px; }
        }
        
        @media (max-width: 768px) {
            #text-overlay { font-size: 80px; }
        }

        @media (max-width: 480px) {
            #text-overlay { font-size: 48px; }
            #generate-button { font-size: 14px; padding: 10px 20px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
        <div id="text-overlay">逗逗の夢</div>
        <div id="button-container">
            <button id="generate-button">次は何色かな？</button>
        </div>
    </div>
    <script>
        // --- グローバル変数 ---
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl');
        let particles = [];
        const numParticles = 50;
        
        let voronoiProgram, blurProgram;
        let quadBuffer;
        let fbo1, fbo2, fboTexture1, fboTexture2;
        let blurScale;
        let spatialGrid;

        let colorPalette = [
            '#E0FBFC', '#C2DFE3', '#AEECEF', '#86BBD8',
            '#97C1A9', '#C6E2E9', '#F4F1DE', '#E8DAB2',
            '#BDE4A8', '#A2D5AB', '#87C38F', '#6B9D7F'
        ];
        
        let textGradientColors = [
            { h: 225/360, s: 0.73, l: 0.57 },
            { h: 271/360, s: 0.76, l: 0.53 }
        ];

        // --- シェーダーコード ---
        const vertShader = `
            attribute vec2 a_position;
            varying vec2 v_texcoord;
            void main() {
                v_texcoord = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const voronoiFragShader = `
            precision mediump float;
            uniform vec2 u_resolution;
            uniform int u_num_points;
            uniform vec2 u_points[${numParticles}];
            uniform vec3 u_colors[${numParticles}];

            void main() {
                vec2 st = gl_FragCoord.xy;
                float min_dist = 1.0e10;
                vec3 final_color = vec3(0.0);

                for (int i = 0; i < ${numParticles}; i++) {
                    if (i >= u_num_points) break;
                    float d = distance(st, u_points[i]);
                    if (d < min_dist) {
                        min_dist = d;
                        final_color = u_colors[i];
                    }
                }
                gl_FragColor = vec4(final_color, 1.0);
            }
        `;
        
        const blurFragShader = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform vec2 u_resolution;
            uniform vec2 u_direction;
            varying vec2 v_texcoord;

            float gaussian(float x, float sigma) {
                return exp(-(x * x) / (2.0 * sigma * sigma));
            }

            void main() {
                vec3 final_color = vec3(0.0);
                float total_weight = 0.0;
                float sigma = 15.0;

                for (float i = -20.0; i <= 20.0; i++) {
                    float weight = gaussian(i, sigma);
                    vec2 offset = u_direction * i / u_resolution;
                    final_color += texture2D(u_texture, v_texcoord + offset).rgb * weight;
                    total_weight += weight;
                }

                gl_FragColor = vec4(final_color / total_weight, 1.0);
            }
        `;

        // --- WebGL初期化 ---
        function initWebGL() {
            if (!gl) {
                console.error("WebGL not supported!");
                return;
            }

            voronoiProgram = createProgram(vertShader, voronoiFragShader);
            blurProgram = createProgram(vertShader, blurFragShader);

            const quadVertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
            
            spatialGrid = new SpatialGrid(canvas.width, canvas.height, 100);
            
            resizeCanvas();
            
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle());
            }

            requestAnimationFrame(draw);
        }
        
        // --- 描画ループ ---
        function draw() {
            updateParticles();
            
            const scaledWidth = Math.floor(canvas.width * blurScale);
            const scaledHeight = Math.floor(canvas.height * blurScale);

            // 1. ボロノイ図を低解像度FBO1に描画
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo1);
            gl.viewport(0, 0, scaledWidth, scaledHeight);
            gl.useProgram(voronoiProgram);
            setupShaderAttributes(voronoiProgram);
            setVoronoiUniforms(blurScale);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 2. 水平ぼかしを低解像度FBO2に描画
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2);
            gl.useProgram(blurProgram);
            setupShaderAttributes(blurProgram);
            setBlurUniforms(fboTexture1, [1, 0], scaledWidth, scaledHeight);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 3. 垂直ぼかしを画面に描画 (フル解像度に戻す)
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(blurProgram);
            setupShaderAttributes(blurProgram);
            setBlurUniforms(fboTexture2, [0, 1], scaledWidth, scaledHeight);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(draw);
        }
        
        function updateParticles() {
            spatialGrid.clear();
            for (let p of particles) spatialGrid.insert(p);
            
            for (let p of particles) {
                p.update();
                const neighbors = spatialGrid.query(p);
                for (let other of neighbors) {
                    if (p !== other) p.checkCollision(other);
                }
                p.edges();
            }
        }

        function setVoronoiUniforms(scale) {
            let positions = [];
            let colors = [];
            for (const p of particles) {
                positions.push(p.pos.x * scale, p.pos.y * scale);
                const c = hexToRgb(p.color);
                colors.push(c.r / 255, c.g / 255, c.b / 255);
            }
            gl.uniform2f(gl.getUniformLocation(voronoiProgram, 'u_resolution'), canvas.width * scale, canvas.height * scale);
            gl.uniform1i(gl.getUniformLocation(voronoiProgram, 'u_num_points'), particles.length);
            gl.uniform2fv(gl.getUniformLocation(voronoiProgram, 'u_points'), positions);
            gl.uniform3fv(gl.getUniformLocation(voronoiProgram, 'u_colors'), colors);
        }
        
        function setBlurUniforms(texture, direction, srcWidth, srcHeight) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(gl.getUniformLocation(blurProgram, 'u_texture'), 0);
            gl.uniform2f(gl.getUniformLocation(blurProgram, 'u_resolution'), srcWidth, srcHeight);
            gl.uniform2fv(gl.getUniformLocation(blurProgram, 'u_direction'), direction);
        }

        // --- ヘルパー関数 ---
        function createShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(vsSource, fsSource) {
            const program = gl.createProgram();
            const vs = createShader(vsSource, gl.VERTEX_SHADER);
            const fs = createShader(fsSource, gl.FRAGMENT_SHADER);
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        function setupShaderAttributes(program) {
            const posAttrib = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(posAttrib);
            gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);
        }
        
        function createFramebuffer(width, height) {
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return { fbo, texture };
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // デバイスの画面幅に応じてぼかし解像度を決定
            blurScale = (window.innerWidth < 1024) ? 1/16 : 1/8;
            
            const scaledW = Math.floor(canvas.width * blurScale);
            const scaledH = Math.floor(canvas.height * blurScale);

            let fb = createFramebuffer(scaledW, scaledH);
            fbo1 = fb.fbo; fboTexture1 = fb.texture;
            fb = createFramebuffer(scaledW, scaledH);
            fbo2 = fb.fbo; fboTexture2 = fb.texture;
            
            spatialGrid = new SpatialGrid(canvas.width, canvas.height, 100);
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        const mapValue = (value, start1, stop1, start2, stop2) => {
            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
        };
        
        window.addEventListener('resize', () => {
             resizeCanvas();
             for (let p of particles) {
                p.pos.x = Math.random() * canvas.width;
                p.pos.y = Math.random() * canvas.height;
            }
        });

        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.pos = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
                const angle = Math.random() * 2 * Math.PI;
                const initialSpeed = Math.random() * 2 + 0.5;
                this.vel = { x: Math.cos(angle) * initialSpeed, y: Math.sin(angle) * initialSpeed };
                this.size = Math.random() * 40 + 40;
                this.mass = this.size * 0.5;
                this.color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            }
            update() {
                const maxSpeed = 4.0, minSpeed = 0.5;
                const center = { x: canvas.width / 2, y: canvas.height / 2 };
                const distFromCenter = Math.sqrt(Math.pow(this.pos.x - center.x, 2) + Math.pow(this.pos.y - center.y, 2));
                const maxDist = Math.sqrt(Math.pow(center.x, 2) + Math.pow(center.y, 2));
                const targetSpeed = mapValue(distFromCenter, 0, maxDist, maxSpeed, minSpeed);
                const currentSpeed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
                if (currentSpeed > 0) {
                    this.vel.x = (this.vel.x / currentSpeed) * targetSpeed;
                    this.vel.y = (this.vel.y / currentSpeed) * targetSpeed;
                }
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;
            }
            checkCollision(other) {
                const dx = other.pos.x - this.pos.x;
                const dy = other.pos.y - this.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const min_dist = this.size / 2 + other.size / 2;

                if (dist < min_dist) {
                    const angle = Math.atan2(dy, dx);
                    const overlap = (min_dist - dist) / 2;
                    this.pos.x -= Math.cos(angle) * overlap;
                    this.pos.y -= Math.sin(angle) * overlap;
                    other.pos.x += Math.cos(angle) * overlap;
                    other.pos.y += Math.sin(angle) * overlap;

                    const v1 = this.vel, v2 = other.vel;
                    const m1 = this.mass, m2 = other.mass;
                    const newVelX1 = (v1.x * (m1 - m2) + (2 * m2 * v2.x)) / (m1 + m2);
                    const newVelY1 = (v1.y * (m1 - m2) + (2 * m2 * v2.y)) / (m1 + m2);
                    const newVelX2 = (v2.x * (m2 - m1) + (2 * m1 * v1.x)) / (m1 + m2);
                    const newVelY2 = (v2.y * (m2 - m1) + (2 * m1 * v1.y)) / (m1 + m2);
                    this.vel = {x: newVelX1, y: newVelY1};
                    other.vel = {x: newVelX2, y: newVelY2};
                }
            }
            edges() {
                if (this.pos.x < 0 || this.pos.x > canvas.width) this.vel.x *= -1;
                if (this.pos.y < 0 || this.pos.y > canvas.height) this.vel.y *= -1;
            }
        }
        
        class SpatialGrid {
            constructor(width, height, cellSize) {
                this.width = width; this.height = height; this.cellSize = cellSize;
                this.cols = Math.ceil(width / cellSize); this.rows = Math.ceil(height / cellSize);
                this.grid = new Array(this.cols * this.rows).fill(null).map(() => []);
            }
            clear() {
                for (let i = 0; i < this.grid.length; i++) this.grid[i] = [];
            }
            insert(p) {
                const c = Math.floor(p.pos.x / this.cellSize), r = Math.floor(p.pos.y / this.cellSize);
                if (c >= 0 && c < this.cols && r >= 0 && r < this.rows) this.grid[c + r * this.cols].push(p);
            }
            query(p) {
                const n = [];
                const c = Math.floor(p.pos.x / this.cellSize), r = Math.floor(p.pos.y / this.cellSize);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const qc = c + i, qr = r + j;
                        if (qc >= 0 && qc < this.cols && qr >= 0 && qr < this.rows) n.push(...this.grid[qc + qr * this.cols]);
                    }
                }
                return n;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initWebGL();
            const generateButton = document.getElementById('generate-button');
            const colorSchemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
            const root = document.documentElement;
            const applyTheme = (isDark) => root.setAttribute('data-theme', isDark ? 'dark' : 'light');
            applyTheme(colorSchemeQuery.matches);
            colorSchemeQuery.addEventListener('change', e => applyTheme(e.matches));
            generateButton.addEventListener('click', () => {
                colorPalette = colorPalette.map(hex => {
                    let hsl = rgbToHsl(...Object.values(hexToRgb(hex)));
                    hsl.h = (hsl.h + 1/3) % 1;
                    return hslToHex(hsl.h, hsl.s, hsl.l);
                });
                for(let p of particles) p.color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                textGradientColors.forEach(c => c.h = (c.h + 1/3) % 1);
                root.style.setProperty('--gradient-color-1', hslToHex(textGradientColors[0].h, textGradientColors[0].s, textGradientColors[0].l));
                root.style.setProperty('--gradient-color-2', hslToHex(textGradientColors[1].h, textGradientColors[1].s, textGradientColors[1].l));
            });
        });
        
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) { h = s = 0; } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s == 0) { r = g = b = l; } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1; if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }
        
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }
        
        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }
    </script>
</body>
</html>
